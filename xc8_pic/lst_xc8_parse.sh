#!/bin/bash -ue

############################# fucntions ###################

sed_args=() # global variable, exported from functions
# sed regexes
rgx_preline='[[:space:]]*[[:digit:]]\+[[:space:]]'
rgx_precode="$rgx_preline"'[[:space:]][[:xdigit:]]\{6\}[[:space:]]\{1,2\}'
rgx_precomment="$rgx_preline"';;'
rgx_prefuncdec="$rgx_preline"';;[[:space:]]\*\+[[:space:]]function[[:space:]]'
rgx_postfuncdec='[[:space:]]\*\+'
rgx_Cfuncname='[a-zA-Z0-9_]\+'
rgx_prefuncname='\(i1\|i2\|\)'
rgx_anyfuncname="$rgx_prefuncname"'_'"${rgx_Cfuncname}"
rgx_anyfuncstart="^${rgx_prefuncdec}\(${rgx_anyfuncname}\)${rgx_postfuncdec}$"
rgx_code1="$rgx_precode"'[[:xdigit:]]\{4\}'
rgx_code2="$rgx_precode"'[[:xdigit:]]\{4\}[[:space:]]\{1,2\}[[:xdigit:]]\{4\}[[:space:]]\+'


rgx_all_func_names() {
	# args: function_names
	echo -n "${rgx_prefuncname}_\("
	echo -n "$1";
	shift;
	printf "%s" "${@/#/\\|}";
	echo -n "\)"
}

sed_args_list() {
	local f
	# args: function_names
	f=$(rgx_all_func_names "$@")
	sed_args=(
		"-n"
		"-e"
"/^${rgx_precode}[[:space:]]\+${f}:\$/,"\
"/^${rgx_precode}[[:space:]]\+__end_of${f}:\$/{"\
"/^${rgx_precode}[[:space:]]\+__end_of${f}:\$/G;p;}"
)
}

sed_args_listlong() {
	local f
	# args: function_names
	f=$(rgx_all_func_names "$@")
	sed_args=(
		"-n"
		"-e" 
"/^${rgx_prefuncdec}${f}${rgx_postfuncdec}\$/,"\
"/^${rgx_prefuncdec}${rgx_anyfuncname}${rgx_postfuncdec}\$/p"
	)
	export sed_args
}

sed_args_listcode() {
	local f
	# args: function_names
	f=$(rgx_all_func_names "$@")
	sed_args=(
		"-n"
		"-e" 
"/^${rgx_precode}[[:space:]]\+${f}:\$/{
	:a;
	/^${rgx_precode}[[:space:]]\+__end_of${f}:\$/{
		q;
	}
	/^${rgx_code1}/{
		p;
	}
	n;
	ba;
}"
	)
	export sed_args
}

sed_args_funcs() {
	sed_args=(
		"-n"
		"-e" 
"/^${rgx_prefuncdec}${rgx_anyfuncname}${rgx_postfuncdec}\$/s"\
"/^${rgx_prefuncdec}\(${rgx_anyfuncname}\)${rgx_postfuncdec}\$/\1/p"
	)
	export sed_args
}

sed_args_Cfuncs() {
	sed_args=(
		"-n"
		"-e" 
"/^${rgx_prefuncdec}${rgx_prefuncname}"'_'"${rgx_Cfuncname}${rgx_postfuncdec}\$/s"\
"/^${rgx_prefuncdec}${rgx_prefuncname}"'_'"\(${rgx_Cfuncname}\)${rgx_postfuncdec}\$/\2/p"
	)
	export sed_args
}

sed_args_callgraph() {
	sed_args=( "
/${rgx_anyfuncstart}/{
	s/${rgx_anyfuncstart}/\1 ->/;
	h;
	: notcalls;
	n;
	/^${rgx_precomment} This function calls:\$/{
		: functioncalled;
		n;
		/^${rgx_precomment}[[:space:]][[:space:]]\+/{
			s/^${rgx_precomment}[[:space:]]\+//;
			/^Nothing$/{
				d;
			}
			s/\$/;|/;
			G;
			s/\n//;
			s/\(.*\)|\(.*\)/\2 \1/;
			p;
			b functioncalled;
		};
		d;
	}
	b notcalls;
}" )
	export sed_args
}

############################ job functions #####################3

do_mode_listlen2() {
	for f in $(all_func_names "$@"); do
		sed_args=(
				"-e" 
"/^${rgx_precode}[[:space:]]\+${f}:\$/,"\
"/^${rgx_precode}[[:space:]]\+__end_of${f}:\$/p"
		)
		func=$(sed -n "${sed_args[@]}" "${files[@]}")
		if [ -z "$func" ]; then
			continue
		fi
		buff=$(sed -n -e "/^${rgx_code1}/p" <<<"$func")
		single=$(wc -l <<<"$buff")
		double=$(echo "$buff" | sed -n -e "/^${rgx_code2}/p" | wc -l)
		echo "$((single+double)) $f"
	done | { $SORT && sort -h || cat; }
}

do_mode_listlen() {
	# args: function_names
	local f
	f=$(rgx_all_func_names "$@")
	sed -n -e \
"/^${rgx_precode}[[:space:]]\+${f}:\$/{
	s/^${rgx_precode}[[:space:]]\+\(${f}\):\$/\1 /
	h;
	:a;
	n;
	/^${rgx_precode}[[:space:]]\+__end_of${f}:\$/{
		g;
		s/\n//g;
		p;
		d;
	}
	/^${rgx_code1}/{
		/^${rgx_code2}/{
			s/.*/1/;
			H;
		}
		s/.*/1/;
		H;
	}
	ba;
}" "${files[@]}" | while IFS=' ' read -r func rest; do
		echo "$(echo -n "$rest" | wc -c) $func";
	done
}

############################# common functions #####################

log() { if $VERBOSE; then echo "> " "$@" >&2; fi; }
error() { echo "ERROR" "$@" >&2; }

usage() {
	local name
	name=$0
	cat <<EOF
USAGE:
      $name -h
      $name [OPTIONS] <MODE> [MODE ARGS]

Program displays various infomations from .lst files generated by Microchip's xc8 compiler.

OPTIONS:
    -f <file.lst>                  - add file to parse, file is in lst format
    -d <dir with *.lst files>      - parse all files in directory that end with *.lst
    -Q                             - less vebose output
    -V                             - more verbose output
    -D                             - debug mode
    -h                             - print this text and exit
    -s                             - sort output
    -S                             - don't sort output
    -k                             - when listing function bodies, remove line numbers and code numbers
                                     usufull for listcode to see only function code
    -M                             - measure execution speed using ttic.sh and ttoc.sh commands


MODEs:
    list     [<function name>,...] - list body of specified function names
    listlong [<function name>,...] - same as list, but more comments
    listcode [<function name>,...] - same as list, but only lines with assembly
    listlen  [<function name>,...] - print instruction count of functions
    funcs                          - list all functions
    Cfuncs                         - print all functions as declared in C sources
    callgraph <.png file>          - generate call graph of functions
    listlen2 [<function name>,...] - slower listlen version, left for reference

if none of -f and -d options are given, then option '-d .obj' is assumed.
If function names are ommitted, all functions are used.

Examples:
      $name -d .obj list SYS_InterruptHigh
      $name list SYS_InterruptHigh
      $name funcs
      $name listlong main 'SYS*'
      $name Cfuncs
      $name listlen
      $name listcode main 'SYS*'

Written by Kamil Cukrowski (c) 2017. Under MIT license.
EOF
}

############################## main ########################

if [ $# -eq 0 ]; then usage; exit 1; fi

# getopts
files=() OPTIONS=() VERBOSE=false DEBUG=${DEBUG:-false} mode="" 
SORT=true SPEEDMEASURE=false REMOVELINENUMBERS=false
args=$(getopt -o f:d:QVDhSMNk -- "$@")
eval set -- "$args"
while true; do
	case "${1/#-/}" in
		f) files+=("$2"); shift; ;;
		d) files+=($(find "$2" -name '*.lst')); shift; ;;
		Q) VERBOSE=false; ;;
		V) VERBOSE=true; ;;
		D) DEBUG=true; set -x; ;;
		h) usage; exit 0; ;;
		s) SORT=true; ;;
		S) SORT=false; ;;
        k) REMOVELINENUMBERS=true; ;;
		M) SPEEDMEASURE=true; ;;
		-) shift; break; ;;
		*) error "Bad argument $1"; exit 1; ;;
	esac
	shift
done
mode="$1"
shift

if $DEBUG; then set -x; fi
if $SPEEDMEASURE; then ttic.sh $$; fi

# check input
if [ -z "${files[*]}" ]; then
	if [ -d .obj ]; then
		files=($(find .obj -name '*.lst'))
	fi
fi
if [ -z "${files[*]}" ]; then
	error ".obj directory not found."
	error "No input *.lst files given"
	exit 1;
fi
for f in "${files[@]}"; do
	if [ ! -e "$f" ]; then
		ERROR "$f not readable"
		exit 1
	fi
done

tempfile=$(mktemp) # global tempfile variable
trap 'rm -f $tempfile' EXIT

############ main work - switch on mode ############
main_do_mode_functions_arguments() {
	# args - function names
	local opt stars
	stars=()
	functions=() # global variable
	if [ $# -eq 0 ]; then
		#error "Mode $mode takes function names as arguments";
		#exit 1;
		set -- "*"
	fi
	for opt in "$@"; do
		if   expr "$opt" : '^[0-9a-zA-Z_]\+$' >/dev/null; then 
			functions+=("$opt")
		elif expr "$opt" : '^[0-9a-zA-Z_\*]\+$' >/dev/null; then 
			stars+=("${opt//'*'/'.*'}")
		else
			error "Function name \"$opt\" is not allowed by C standard!";
			exit 1;
		fi
	done
	if [ -n "${stars[*]}" ]; then
		functions+=($(egrep "^$(IFS='|'; echo "${stars[*]}";)$" <(SORT=true main_do_mode Cfuncs)))
	fi
	IFS=$'\n' functions=($(sort -u <<<"${functions[*]}"))
	log "Searching for functions: ""${functions[@]}"
	if [ -z "${#functions[*]}" ]; then
		error "No functions found!"
		exit 1;
	fi
	export functions
}
main_do_mode() {
	local mode functions
	mode=$1
	shift
	case "$mode" in
	Cfuncs|funcs)
		eval "sed_args_${mode}"
		sed "${sed_args[@]}" "${files[@]}" | { if $SORT; then sort -u; else cat; fi; }
		;;
	list|listlong|listcode)
		main_do_mode_functions_arguments "$@"
		eval "sed_args_${mode}" "${functions[@]}"
		sed "${sed_args[@]}" "${files[@]}" | \
			{ if $REMOVELINENUMBERS; then sed "s/^${rgx_precode}[[:xdigit:]]\{4\}[[:space:]]\{1,2\}\([[:xdigit:]]\{4\}\)\?[[:space:]]\+//"; else cat; fi; }
		;;
	listlen)
		main_do_mode_functions_arguments "$@"
		do_mode_listlen "${functions[@]}" | { if $SORT; then sort -h | column -t -s' '; else cat; fi; }
		;;
	listlen2)
		main_do_mode_functions_arguments "$@"
		do_mode_listlen2 "${functions[@]}" | { if $SORT; then sort -h | column -t -s' '; else cat; fi; }
		;;
	callgraph)
		if [ $# -eq 0 ]; then error "Mode $mode takes .png file output name"; exit 1; fi
		sed_args_callgraph
		(
			echo 'digraph G {' 
			sed -n -e "${sed_args[@]}" ${files[@]}
			echo '}' 
		) > $tempfile
		( set -x; 
		dot $tempfile -Tpng -o ${1}
		)
		;;
	*) error "Unknown mode: $mode"; exit 1; ;;
	esac
}

########## substitute '*' in function modes for all passing function
log "Running mode=\"$mode\" for arguments: $* "

############# finally do smth main mode ###########################
main_do_mode "$mode" "$@"

if $SPEEDMEASURE; then ttoc.sh $$ >&2; fi
